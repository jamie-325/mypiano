<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>MR Live Synthesia Piano</title>

<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

<style>
  body { margin: 0; overflow: hidden; background: black; }
</style>
</head>

<body>

<a-scene background="color: #050510" xr-mode-ui="enabled: true">

  <!-- LIGHTING -->
  <a-entity light="type: ambient; intensity: 0.8"></a-entity>

  <!-- MAIN WRAPPER -->
  <a-entity id="piano-wrapper" position="0 1.2 -1.5">

    <!-- SYNTHESIA ROLL -->
    <a-entity id="roll"></a-entity>

    <!-- PIANO -->
    <a-entity id="keyboard"></a-entity>

  </a-entity>

  <!-- INFO PANEL -->
  <a-entity position="0 2 -1.5">
    <a-plane width="2.2" height="0.8" color="#111" opacity="0.9"></a-plane>
    <a-text id="note-display"
            position="-1 0.2 0.01"
            width="2"
            align="left"
            color="#39FF14"
            value="Waiting for MIDI...">
    </a-text>
    <a-text id="event-log"
            position="-1 -0.1 0.01"
            width="2"
            align="left"
            color="#aaa"
            value="">
    </a-text>
  </a-entity>

  <a-camera position="0 1.6 0"></a-camera>

</a-scene>

<script>

// ─────────────────────────────
// GLOBAL STATE
// ─────────────────────────────

window.midiState = {
  devices: [],
  activeNotes: {},
  lastEvent: null
};

const roll = document.getElementById("roll");
const keyboard = document.getElementById("keyboard");
const noteDisplay = document.getElementById("note-display");
const eventLog = document.getElementById("event-log");

const START_NOTE = 21;
const END_NOTE = 108;
const WHITE_KEY_WIDTH = 0.045;
const BLACK_KEY_WIDTH = 0.028;
const FALL_SPEED = 1.5;
const MAX_LIFE = 6;

let keyMap = {};
let keyPositions = {};
let whiteIndex = 0;
let activeRolls = [];

// ─────────────────────────────
// UTILITIES
// ─────────────────────────────

function midiToName(n) {
  const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  return names[n % 12] + (Math.floor(n / 12) - 1);
}

function midiToFreq(n) {
  return (440 * Math.pow(2, (n - 69) / 12)).toFixed(2);
}

function isBlack(n) {
  return [1,3,6,8,10].includes(n % 12);
}

function isRightHand(n) {
  return n >= 60;
}

// ─────────────────────────────
// BUILD 88-KEY PIANO
// ─────────────────────────────

function buildKeyboard() {

  for (let note = START_NOTE; note <= END_NOTE; note++) {

    const black = isBlack(note);

    const key = document.createElement("a-box");
    key.setAttribute("height", black ? 0.05 : 0.04);
    key.setAttribute("depth", black ? 0.18 : 0.28);
    key.setAttribute("width", black ? BLACK_KEY_WIDTH : WHITE_KEY_WIDTH);
    key.setAttribute("color", black ? "#000" : "#fff");
    key.setAttribute("position", {
      x: whiteIndex * WHITE_KEY_WIDTH,
      y: black ? 0.03 : 0,
      z: black ? -0.06 : 0
    });

    if (!black) whiteIndex++;

    keyboard.appendChild(key);
    keyMap[note] = key;
    keyPositions[note] = whiteIndex * WHITE_KEY_WIDTH;
  }

  keyboard.object3D.position.x = -(whiteIndex * WHITE_KEY_WIDTH) / 2;
}

// ─────────────────────────────
// MIDI SETUP
// ─────────────────────────────

function setupMIDI() {

  if (!navigator.requestMIDIAccess) {
    noteDisplay.setAttribute("value", "WebMIDI not supported.");
    return;
  }

  navigator.requestMIDIAccess().then(access => {

    function connectInputs() {
      window.midiState.devices = [];
      for (let input of access.inputs.values()) {
        window.midiState.devices.push(input.name);
        input.onmidimessage = handleMIDI;
      }
      noteDisplay.setAttribute("value",
        "Connected:\n" + window.midiState.devices.join("\n"));
    }

    access.onstatechange = connectInputs;
    connectInputs();

  });
}

function handleMIDI(event) {

  const [status, data1, data2] = event.data;
  const type = status & 0xf0;

  if (type === 0x90 && data2 > 0)
    noteOn(data1, data2);

  else if (type === 0x80 || (type === 0x90 && data2 === 0))
    noteOff(data1);
}

// ─────────────────────────────
// NOTE ON / OFF
// ─────────────────────────────

function noteOn(note, velocity) {

  const now = performance.now() / 1000;

  window.midiState.activeNotes[note] = true;
  window.midiState.lastEvent = note;

  keyMap[note]?.setAttribute("color", "#22c55e");

  const rollBox = document.createElement("a-box");
  rollBox.setAttribute("width",
    isBlack(note) ? BLACK_KEY_WIDTH : WHITE_KEY_WIDTH);
  rollBox.setAttribute("depth", 0.12);
  rollBox.setAttribute("color",
    isRightHand(note) ? "#38bdf8" : "#a78bfa");

  roll.appendChild(rollBox);

  activeRolls.push({
    note,
    start: now,
    release: null,
    el: rollBox
  });

  noteDisplay.setAttribute("value",
    `Note: ${midiToName(note)}\n` +
    `MIDI: ${note}\n` +
    `Velocity: ${velocity}\n` +
    `Freq: ${midiToFreq(note)} Hz`);

  logEvent(`ON  ${midiToName(note)}  vel:${velocity}`);
}

function noteOff(note) {

  const now = performance.now() / 1000;

  delete window.midiState.activeNotes[note];

  keyMap[note]?.setAttribute("color",
    isBlack(note) ? "#000" : "#fff");

  const rollObj = activeRolls.find(r => r.note === note && !r.release);
  if (rollObj) rollObj.release = now;

  logEvent(`OFF ${midiToName(note)}`);
}

// ─────────────────────────────
// LOG
// ─────────────────────────────

let logLines = [];

function logEvent(text) {
  logLines.unshift(text);
  if (logLines.length > 6) logLines.pop();
  eventLog.setAttribute("value", logLines.join("\n"));
}

// ─────────────────────────────
// SYNTHESIA TICK ENGINE
// ─────────────────────────────

AFRAME.scenes[0].addEventListener("tick", () => {

  const now = performance.now() / 1000;

  activeRolls = activeRolls.filter(obj => {

    const heldTime = obj.release
      ? obj.release - obj.start
      : now - obj.start;

    const age = now - obj.start;
    const height = heldTime * FALL_SPEED;
    const y = age * FALL_SPEED;

    obj.el.setAttribute("height", height);
    obj.el.setAttribute("position", {
      x: keyPositions[obj.note] - (whiteIndex * WHITE_KEY_WIDTH) / 2,
      y: y - height / 2 + 0.3,
      z: 0
    });

    if (age > MAX_LIFE) {
      obj.el.remove();
      return false;
    }

    return true;
  });

});

// ─────────────────────────────
// INIT
// ─────────────────────────────

buildKeyboard();
setupMIDI();

</script>

</body>
</html>
